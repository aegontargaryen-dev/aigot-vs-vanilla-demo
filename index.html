<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AIgot vs Vanilla — EntityTracker Broad-Phase Benchmark</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif; background:#0b0f14; color:#e6edf3; }
    header { padding: 18px 20px; border-bottom: 1px solid #1f2a37; display:flex; gap:16px; align-items:center; flex-wrap:wrap;}
    header h1 { margin:0; font-size: 15px; font-weight: 700; }
    .hint { color:#9aa4b2; font-size:12px; line-height: 1.35; }
    .panel { padding: 16px 20px; display:grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    .card { background:#0f1720; border:1px solid #1f2a37; border-radius: 14px; padding: 14px; box-shadow: 0 10px 25px rgba(0,0,0,.25); }
    .card h2 { margin: 0 0 10px; font-size: 13px; font-weight: 700; color:#cbd5e1; }
    .grid { display:grid; grid-template-columns: repeat(4,minmax(0,1fr)); gap:10px; }
    .field { display:flex; flex-direction:column; gap:6px; }
    label { font-size: 11px; color:#9aa4b2; }
    input[type="number"]{
      width:100%; border-radius:10px; border:1px solid #243244; background:#0b1220; color:#e6edf3; padding:10px;
      outline:none;
    }
    .btns { display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px; }
    button {
      border:1px solid #2a3a52; background:#101a2a; color:#e6edf3; padding:10px 12px; border-radius: 12px;
      font-weight: 700; cursor:pointer;
    }
    button:hover { filter: brightness(1.08); }
    button:active { transform: translateY(1px); }
    .stats { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .stat { background:#0b1220; border:1px solid #243244; border-radius: 12px; padding: 10px; }
    .stat .k { font-size: 11px; color:#9aa4b2; }
    .stat .v { font-size: 15px; font-weight: 800; margin-top: 4px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    canvas { width: 100%; height: 460px; background:#070a0f; border:1px solid #1f2a37; border-radius: 14px; display:block; }
    footer { padding: 14px 20px; border-top: 1px solid #1f2a37; color:#9aa4b2; font-size:12px; }
    .warn { color:#fbbf24; }
    .ok { color:#86efac; }
  </style>
</head>
<body>
  <header>
    <h1>AIgot vs Vanilla — EntityTracker benchmark (chunk buckets broad-phase vs brute force)</h1>
    <span class="hint">
      This demonstrates why AIgot scales better: vanilla considers every entity for every player (O(P·E)),
      while AIgot only considers entities in chunks intersecting the tracking range (broad-phase + box check).
    </span>
  </header>

  <div class="panel">
    <div class="card">
      <h2>Configuration</h2>
      <div class="grid">
        <div class="field">
          <label>Entities (E)</label>
          <input id="entities" type="number" min="1000" max="1500000" step="1000" value="120000" />
        </div>
        <div class="field">
          <label>Players (P)</label>
          <input id="players" type="number" min="1" max="800" step="1" value="120" />
        </div>
        <div class="field">
          <label>World size (width/height)</label>
          <input id="worldSize" type="number" min="256" max="16384" step="64" value="4096" />
        </div>
        <div class="field">
          <label>Chunk size (blocks)</label>
          <input id="chunkSize" type="number" min="8" max="64" step="8" value="16" />
        </div>

        <div class="field">
          <label>Tracking range (blocks)</label>
          <input id="range" type="number" min="16" max="768" step="16" value="128" />
        </div>
        <div class="field">
          <label>Simulated ticks</label>
          <input id="ticks" type="number" min="10" max="2000" step="10" value="120" />
        </div>
        <div class="field">
          <label>Vanilla ops budget (per run)</label>
          <input id="budget" type="number" min="1000000" max="2000000000" step="1000000" value="150000000" />
        </div>
        <div class="field">
          <label>Moved players ratio (%)</label>
          <input id="movedPct" type="number" min="0" max="100" step="5" value="35" />
        </div>
      </div>

      <div class="btns">
        <button id="regen">Generate world</button>
        <button id="run">Run benchmark</button>
        <button id="animate">Animate (stress)</button>
      </div>

      <div class="hint" style="margin-top:10px;">
        <b>Notes:</b><br/>
        • <span class="mono">Moved players ratio</span> approximates AIgot-style “only rescan viewers that moved chunks”.<br/>
        • Vanilla may be <span class="warn">budgeted</span> to keep the tab responsive; if budgeted, we estimate full-time based on measured throughput.
      </div>
    </div>

    <div class="card">
      <h2>Results</h2>
      <div class="stats">
        <div class="stat">
          <div class="k">Vanilla time</div>
          <div class="v" id="tVanilla">—</div>
        </div>
        <div class="stat">
          <div class="k">AIgot time</div>
          <div class="v" id="tAigot">—</div>
        </div>

        <div class="stat">
          <div class="k">Vanilla checks</div>
          <div class="v mono" id="cVanilla">—</div>
        </div>
        <div class="stat">
          <div class="k">AIgot candidate checks</div>
          <div class="v mono" id="cAigot">—</div>
        </div>

        <div class="stat">
          <div class="k">Checks reduction</div>
          <div class="v" id="reduction">—</div>
        </div>
        <div class="stat">
          <div class="k">Speedup</div>
          <div class="v" id="speedup">—</div>
        </div>
      </div>

      <div class="hint" style="margin-top:10px;">
        <span id="modeNote">—</span>
      </div>
    </div>

    <div class="card" style="grid-column: 1 / -1;">
      <h2>Visualization (chunks + selected player range)</h2>
      <canvas id="cv" width="1200" height="460"></canvas>
      <div class="hint" style="margin-top:10px;">
        Dots: entities (gray, sampled) and players (blue). White square: tracking range of the selected player.
        AIgot only inspects buckets for chunks overlapped by that square.
      </div>
    </div>
  </div>

  <footer>
    This is a conceptual benchmark that mirrors the core advantage: broad-phase spatial partitioning avoids expensive per-viewer work outside range.
    In real NMS, the win compounds because “candidate checks” gate far heavier logic (packets, metadata, attributes).
  </footer>

  <script>
    // ---------- formatting ----------
    const $ = (id) => document.getElementById(id);
    const fmtInt = (n) => Math.round(n).toLocaleString("en-US");
    const fmtMs  = (n) => (n >= 1000 ? (n/1000).toFixed(2) + " s" : n.toFixed(2) + " ms");
    const now = () => performance.now();

    // ---------- chunk key packing ----------
    // Pack (cx, cz) into one 32-bit number: 16 bits each with offset.
    // This is very fast and avoids BigInt/strings.
    const OFF = 32768; // supports chunk coords in [-32768, 32767]
    function packKey(cx, cz) {
      return ((cx + OFF) << 16) | ((cz + OFF) & 0xFFFF);
    }

    // ---------- world state (Structure of Arrays) ----------
    const world = {
      size: 4096,
      chunkSize: 16,
      range: 128,

      E: 0,
      P: 0,

      ex: null, // Float32Array
      ez: null, // Float32Array
      ecx: null, // Int32Array
      ecz: null, // Int32Array
      ekey: null, // Int32Array

      px: null, // Float32Array
      pz: null, // Float32Array
      pcx: null, // Int32Array
      pcz: null, // Int32Array
      pmoved: null, // Uint8Array (1 if moved)

      // chunk buckets: key -> array of entity indices
      buckets: new Map(),

      selectedPlayer: 0
    };

    function rand01() { return Math.random(); }

    function buildWorld(E, P, size, chunkSize) {
      world.size = size;
      world.chunkSize = chunkSize;
      world.E = E;
      world.P = P;

      world.ex = new Float32Array(E);
      world.ez = new Float32Array(E);
      world.ecx = new Int32Array(E);
      world.ecz = new Int32Array(E);
      world.ekey = new Int32Array(E);

      world.px = new Float32Array(P);
      world.pz = new Float32Array(P);
      world.pcx = new Int32Array(P);
      world.pcz = new Int32Array(P);
      world.pmoved = new Uint8Array(P);

      world.buckets = new Map();
      world.selectedPlayer = 0;

      const s = size;
      const cs = chunkSize;

      // entities
      for (let i = 0; i < E; i++) {
        const x = rand01() * s;
        const z = rand01() * s;
        const cx = (x / cs) | 0;
        const cz = (z / cs) | 0;
        const key = packKey(cx, cz);

        world.ex[i] = x;
        world.ez[i] = z;
        world.ecx[i] = cx;
        world.ecz[i] = cz;
        world.ekey[i] = key;

        let bucket = world.buckets.get(key);
        if (!bucket) {
          bucket = [];
          world.buckets.set(key, bucket);
        }
        bucket.push(i);
      }

      // players
      for (let i = 0; i < P; i++) {
        const x = rand01() * s;
        const z = rand01() * s;
        world.px[i] = x;
        world.pz[i] = z;
        world.pcx[i] = (x / cs) | 0;
        world.pcz[i] = (z / cs) | 0;
        world.pmoved[i] = 0;
      }
    }

    function movePlayers(movedPct) {
      const s = world.size;
      const cs = world.chunkSize;
      const P = world.P;

      // Instead of checking exact chunk crossing every time, we approximate “needs rescan”
      // with a controlled probability (movedPct). This mirrors AIgot "movedScratch" behavior.
      const movedProb = movedPct / 100;

      for (let i = 0; i < P; i++) {
        // random small jitter
        let x = world.px[i] + (rand01() - 0.5) * 28;
        let z = world.pz[i] + (rand01() - 0.5) * 28;

        // occasional hop
        if (rand01() < 0.05) {
          x += (rand01() - 0.5) * 200;
          z += (rand01() - 0.5) * 200;
        }

        // clamp
        if (x < 0) x = 0;
        if (z < 0) z = 0;
        if (x > s) x = s;
        if (z > s) z = s;

        world.px[i] = x;
        world.pz[i] = z;

        // update chunk coords (cheap)
        const cx = (x / cs) | 0;
        const cz = (z / cs) | 0;
        world.pcx[i] = cx;
        world.pcz[i] = cz;

        // moved flag (approx)
        world.pmoved[i] = (rand01() < movedProb) ? 1 : 0;
      }
    }

    // ---------- algorithms ----------
    // Vanilla (brute force): P * E checks. Budgeted to prevent tab freeze on huge inputs.
    function runVanillaTicks(ticks, opsBudget) {
      const P = world.P, E = world.E;
      const R = world.range;
      const R2 = R * R;

      let opsDone = 0;
      const totalOps = P * E * ticks;

      let tStart = now();
      let hits = 0;

      // We run until budget is reached, then estimate remaining time via throughput.
      outer:
      for (let t = 0; t < ticks; t++) {
        for (let p = 0; p < P; p++) {
          const px = world.px[p], pz = world.pz[p];
          for (let e = 0; e < E; e++) {
            // budget check (very cheap)
            opsDone++;
            if (opsDone >= opsBudget) break outer;

            const dx = world.ex[e] - px;
            const dz = world.ez[e] - pz;
            if (dx*dx + dz*dz <= R2) hits++;
          }
        }
      }

      const tEnd = now();
      const measuredMs = tEnd - tStart;

      // Throughput (ops/ms) from measured portion
      const opsPerMs = opsDone > 0 ? (opsDone / measuredMs) : 0;
      const estimatedMs = (opsPerMs > 0) ? (totalOps / opsPerMs) : Infinity;

      const budgeted = opsDone < totalOps;
      return {
        budgeted,
        measuredMs,
        estimatedMs,
        checksExact: totalOps,
        hitsMeasured: hits,
        opsDone
      };
    }

    // AIgot (broad-phase by chunk buckets + box check), only for "moved" players (pmoved=1)
    function runAigotTicks(ticks, movedPct) {
      const P = world.P, E = world.E;
      const cs = world.chunkSize;
      const R = world.range;
      const R2 = R * R;

      const rChunks = Math.ceil(R / cs);

      let checks = 0;
      let hits = 0;

      const tStart = now();

      for (let t = 0; t < ticks; t++) {
        // movement happens once per tick
        movePlayers(movedPct);

        for (let p = 0; p < P; p++) {
          if (world.pmoved[p] === 0) continue; // mimic "only rescan moved viewers"

          const px = world.px[p], pz = world.pz[p];
          const pcx = world.pcx[p], pcz = world.pcz[p];

          for (let cx = pcx - rChunks; cx <= pcx + rChunks; cx++) {
            for (let cz = pcz - rChunks; cz <= pcz + rChunks; cz++) {
              const bucket = world.buckets.get(packKey(cx, cz));
              if (!bucket) continue;

              // tight loop
              for (let i = 0, n = bucket.length; i < n; i++) {
                const ei = bucket[i];

                // cheap box-check first (like AIgot's dx/dz range cull)
                const dx = world.ex[ei] - px;
                checks++;
                if (dx > R || dx < -R) continue;

                const dz = world.ez[ei] - pz;
                if (dz > R || dz < -R) continue;

                if (dx*dx + dz*dz <= R2) hits++;
              }
            }
          }
        }
      }

      const tEnd = now();
      return { ms: (tEnd - tStart), checks, hits };
    }

    function benchmark() {
      const ticks = +$("ticks").value;
      world.range = +$("range").value;

      const movedPct = +$("movedPct").value;
      const budget = +$("budget").value;

      // Vanilla first: budgeted brute force on current positions (no movement inside)
      // To keep it fair-ish, we do a single movement before vanilla to avoid pathological clustering.
      movePlayers(movedPct);

      const v = runVanillaTicks(ticks, budget);
      const a = runAigotTicks(ticks, movedPct);

      // reduction & speedup (using estimated vanilla time when budgeted)
      const vanillaTime = v.budgeted ? v.estimatedMs : v.measuredMs;
      const speed = vanillaTime / a.ms;
      const red = 100 * (1 - (a.checks / v.checksExact));

      $("tVanilla").textContent = v.budgeted
        ? `${fmtMs(v.measuredMs)} (measured) · ${fmtMs(v.estimatedMs)} (estimated)`
        : fmtMs(v.measuredMs);

      $("tAigot").textContent = fmtMs(a.ms);

      $("cVanilla").textContent = fmtInt(v.checksExact);
      $("cAigot").textContent = fmtInt(a.checks);

      $("reduction").innerHTML = `<span class="${red > 0 ? 'ok' : ''}">${red.toFixed(1)}%</span>`;
      $("speedup").innerHTML = `<span class="${speed >= 1 ? 'ok' : ''}">${speed.toFixed(2)}x</span>`;

      $("modeNote").innerHTML = v.budgeted
        ? `<span class="warn">Vanilla was budgeted</span>: ran ${fmtInt(v.opsDone)} ops to keep the browser responsive, then estimated full time from throughput.`
        : `Vanilla ran fully (no budget needed).`;

      draw();
    }

    // ---------- visualization ----------
    function draw() {
      const cv = $("cv");
      const ctx = cv.getContext("2d");
      const W = cv.width, H = cv.height;

      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = "#070a0f";
      ctx.fillRect(0,0,W,H);

      // grid (chunks)
      const s = world.size;
      const cs = world.chunkSize;
      const scaleX = W / s;
      const scaleZ = H / s;

      const chunkPx = cs * scaleX;
      const chunkPz = cs * scaleZ;

      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.lineWidth = 1;

      for (let x = 0; x <= W; x += chunkPx) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let z = 0; z <= H; z += chunkPz) {
        ctx.beginPath();
        ctx.moveTo(0, z);
        ctx.lineTo(W, z);
        ctx.stroke();
      }

      // entities (sampled to keep drawing cheap)
      const E = world.E;
      const step = Math.max(1, (E / 9000) | 0);

      ctx.fillStyle = "rgba(200,200,200,0.35)";
      for (let i = 0; i < E; i += step) {
        const x = world.ex[i] * scaleX;
        const z = world.ez[i] * scaleZ;
        ctx.fillRect(x, z, 2, 2);
      }

      // players
      const P = world.P;
      ctx.fillStyle = "rgba(80,160,255,0.95)";
      for (let i = 0; i < P; i++) {
        const x = world.px[i] * scaleX;
        const z = world.pz[i] * scaleZ;
        ctx.fillRect(x - 2, z - 2, 5, 5);
      }

      // selected player's range square
      const sp = world.selectedPlayer < P ? world.selectedPlayer : 0;
      const px = world.px[sp], pz = world.pz[sp];
      const R = world.range;

      const x0 = (px - R) * scaleX;
      const z0 = (pz - R) * scaleZ;
      const ww = (2 * R) * scaleX;
      const hh = (2 * R) * scaleZ;

      ctx.strokeStyle = "rgba(255,255,255,0.9)";
      ctx.lineWidth = 2;
      ctx.strokeRect(x0, z0, ww, hh);

      // highlight selected player
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.fillRect(px * scaleX - 3, pz * scaleZ - 3, 7, 7);
    }

    // click to select nearest player
    $("cv").addEventListener("click", (ev) => {
      const rect = $("cv").getBoundingClientRect();
      const mx = (ev.clientX - rect.left) / rect.width;
      const mz = (ev.clientY - rect.top) / rect.height;

      const P = world.P;
      let best = 0;
      let bestD = Infinity;

      for (let i = 0; i < P; i++) {
        const dx = (world.px[i] / world.size) - mx;
        const dz = (world.pz[i] / world.size) - mz;
        const d2 = dx*dx + dz*dz;
        if (d2 < bestD) { bestD = d2; best = i; }
      }
      world.selectedPlayer = best;
      draw();
    });

    // ---------- controls ----------
    function regen() {
      const E = +$("entities").value;
      const P = +$("players").value;
      const size = +$("worldSize").value;
      const cs = +$("chunkSize").value;
      world.range = +$("range").value;

      buildWorld(E, P, size, cs);
      draw();

      $("tVanilla").textContent = "—";
      $("tAigot").textContent = "—";
      $("cVanilla").textContent = "—";
      $("cAigot").textContent = "—";
      $("reduction").textContent = "—";
      $("speedup").textContent = "—";
      $("modeNote").textContent = "—";
    }

    $("regen").addEventListener("click", regen);
    $("run").addEventListener("click", benchmark);

    // animation/stress loop
    let anim = false;
    let raf = 0;
    function toggleAnim() {
      anim = !anim;
      $("animate").textContent = anim ? "Stop animation" : "Animate (stress)";
      if (anim) {
        const loop = () => {
          benchmark();
          raf = requestAnimationFrame(loop);
        };
        loop();
      } else {
        cancelAnimationFrame(raf);
      }
    }
    $("animate").addEventListener("click", toggleAnim);

    // init
    regen();
  </script>
</body>
</html>
